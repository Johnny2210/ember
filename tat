[1mdiff --git a/embedding/embedding_test.go b/embedding/embedding_test.go[m
[1mindex 802c903..923356f 100644[m
[1m--- a/embedding/embedding_test.go[m
[1m+++ b/embedding/embedding_test.go[m
[36m@@ -1,14 +1,104 @@[m
 package embedding[m
 [m
 import ([m
[32m+[m	[32m"bytes"[m
[32m+[m	[32m"crypto/rand"[m
 	"io"[m
[32m+[m	[32m"io/ioutil"[m
[32m+[m	[32m"os"[m
 	"strings"[m
 	"testing"[m
 [m
[32m+[m	[32m"github.com/maja42/ember"[m
 	"github.com/maja42/ember/internal"[m
 	"github.com/stretchr/testify/assert"[m
 )[m
 [m
[32m+[m[32mfunc TestEmbed(t *testing.T) {[m
[32m+[m	[32mvar out bytes.Buffer[m
[32m+[m	[32mexe := prepareExecutableData()[m
[32m+[m	[32mattachments := map[string]io.ReadSeeker{[m
[32m+[m		[32m"att1": strings.NewReader("first content"),[m
[32m+[m		[32m"att2": strings.NewReader("second content"),[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32merr := Embed(&out, strings.NewReader(exe), attachments, nil)[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m
[32m+[m	[32mout.WriteString("some other content attached later via another 3rd-party application")[m
[32m+[m
[32m+[m	[32m// verify executable content[m
[32m+[m	[32mexeBytes := out.Bytes()[:len(exe)][m
[32m+[m	[32massert.Equal(t, []byte(exe), exeBytes)[m
[32m+[m
[32m+[m	[32m// write content to disk[m
[32m+[m	[32mtmpFile, err := ioutil.TempFile("", "")[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m	[32mio.Copy(tmpFile, &out)[m
[32m+[m	[32mtmpFile.Close()[m
[32m+[m	[32mdefer os.Remove(tmpFile.Name())[m
[32m+[m
[32m+[m	[32m// verify 'ember' can extract the embedded attachments[m
[32m+[m	[32matt, err := ember.OpenExe(tmpFile.Name())[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m	[32massert.Equal(t, 2, att.Count())[m
[32m+[m	[32massert.Equal(t, int64(13), att.Size("att1"))[m
[32m+[m	[32massert.Equal(t, int64(14), att.Size("att2"))[m
[32m+[m
[32m+[m	[32mcontent, err := ioutil.ReadAll(att.Reader("att1"))[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m	[32massert.Equal(t, []byte("first content"), content)[m
[32m+[m
[32m+[m	[32mcontent, err = ioutil.ReadAll(att.Reader("att2"))[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m	[32massert.Equal(t, []byte("second content"), content)[m
[32m+[m
[32m+[m	[32merr = att.Close()[m
[32m+[m	[32massert.NoError(t, err)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunc Test_verifyTargetExe(t *testing.T) {[m
[32m+[m	[32mr := strings.NewReader(prepareExecutableData())[m
[32m+[m	[32merr := verifyTargetExe(r)[m
[32m+[m	[32massert.Nil(t, err)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunc Test_verifyTargetExe_invalidFile(t *testing.T) {[m
[32m+[m	[32mr := strings.NewReader("does not contain magic marker")[m
[32m+[m	[32merr := verifyTargetExe(r)[m
[32m+[m	[32massert.EqualError(t, err, "incompatible (magic string not found)")[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunc Test_verifyTargetExe_alreadyAugmented(t *testing.T) {[m
[32m+[m	[32mvar buf bytes.Buffer[m
[32m+[m	[32m_ = internal.WriteBoundary(&buf)[m
[32m+[m
[32m+[m	[32mcontent := prepareExecutableData()[m
[32m+[m	[32mcontent += buf.String()[m
[32m+[m	[32mcontent += "some more content"[m
[32m+[m
[32m+[m	[32mr := strings.NewReader(content)[m
[32m+[m
[32m+[m	[32merr := verifyTargetExe(r)[m
[32m+[m	[32massert.EqualError(t, err, "already contains embedded content")[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunc Test_verifyTargetExe_embedderIsInvalid(t *testing.T) {[m
[32m+[m	[32m// Open the test-executable (which contains 'embedding' and imports 'internal')[m
[32m+[m	[32m// - the executable should not contain the magic marker string[m
[32m+[m	[32m// This test only works if executed on its own. If the whole ember-package is tested,[m
[32m+[m	[32m// the 'ember' package and therefore the magic-marker will be part of the test-executable.[m
[32m+[m
[32m+[m	[32m//path, err := os.Executable()[m
[32m+[m	[32m//assert.NoError(t, err)[m
[32m+[m	[32m//file, err := os.Open(path)[m
[32m+[m	[32m//assert.NoError(t, err)[m
[32m+[m	[32m//defer file.Close()[m
[32m+[m	[32m//[m
[32m+[m	[32m//err = verifyTargetExe(file)[m
[32m+[m	[32m//assert.EqualError(t, err, "incompatible (magic string not found)")[m
[32m+[m[32m}[m
[32m+[m
 func Test_buildTOC(t *testing.T) {[m
 	r1 := strings.NewReader("content 1")[m
 	r2 := strings.NewReader("second content")[m
[36m@@ -31,3 +121,19 @@[m [mfunc Test_buildTOC(t *testing.T) {[m
 		Size: 14,[m
 	})[m
 }[m
[32m+[m
[32m+[m[32mfunc prepareExecutableData() string {[m
[32m+[m	[32mrandBytes := make([]byte, 0, 100)[m
[32m+[m	[32mif _, err := rand.Read(randBytes); err != nil {[m
[32m+[m		[32mpanic(err)[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mexeData := "This is the executable content"[m
[32m+[m	[32mexeData += string(randBytes)[m
[32m+[m	[32mexeData += "~~MagicMarker for XXX~~"[m
[32m+[m	[32mexeData += "Some more content"[m
[32m+[m	[32mexeData += string(randBytes)[m
[32m+[m
[32m+[m	[32mexeData = strings.ReplaceAll(exeData, "XXX", compatibleVersion)[m
[32m+[m	[32mreturn exeData[m
[32m+[m[32m}[m
